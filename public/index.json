[{"content":"\u003cimg src=\"https://sm.ign.com/ign_es/tag/s/steam/steam_rbez.jpg\" alt=\"drawing\" width=\"50%\" style=\"display: block; margin-left: auto; margin-right: auto; margin-bottom: 5%; width: 50%;\"/\u003e\n\u003ch3 id=\"preparacion-de-datos\"\u003ePreparacion de datos\u003c/h3\u003e\n\u003cp\u003eLa idea principal de este post es analizar los inicios de la preparación de datos en datasets reales con grandes cantidades de información.\nPara esto se eligió el dataset de \u003ca href=\"https://www.kaggle.com/datasets/antonkozyriev/game-recommendations-on-steam\"\u003erecomendaciones de juegos en Steam\u003c/a\u003e (plataforma de distribución digital de videojuegos), el cual cuenta con datos oficiales de la plataforma, y según la descripción del mismo esta compuesto por mas de 41 millones de recomendaciones de usuarios de Steam.\nEste dataset contiene 3 CSVs, uno de juegos, otro de recomendaciones, y otro de usuarios, y tambien contiene un archivo json con metadata de los juegos.\u003c/p\u003e\n\u003cp\u003ePara comenzar con la preparación de datos, es importante conocer el dataset. Esto permitirá en primera instancia entender qué es lo que se puede hacer con los datos, y una vez definido el objetivo, validar que predictores son los más importantes para poder alcanzarlo.\nAl tener 3 CSVs, será necesario también encontrar puntos en común para poder correlacionarlos, y de esa forma poder utilizar toda la información posible, lo que ayudará a conseguir un mejor resultado.\u003c/p\u003e\n\u003ch3 id=\"análisis-de-predictores\"\u003eAnálisis de predictores\u003c/h3\u003e\n\u003ch5 id=\"csv-de-juegos\"\u003eCSV de juegos:\u003c/h5\u003e\n\u003cp\u003eEste CSV contiene datos acerca de una gran variedad de juegos de Steam. Dentro de los campos que este tiene se encuentran:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eapp_id\u003c/strong\u003e: ID del juego en Steam. Este campo será importante para poder \u0026ldquo;mergear\u0026rdquo; los datasets (luego se verá que tanto el json con metadata como el CSV de recomendaciones referencian este app_id) (campo integer)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003etitle\u003c/strong\u003e: Nombre del juego. Notar que algunos nombres tienen mal el formato en excel, principalmente los que utilizan simbolos como tm (trademark) o copyright, pero dentro de un editor de texto se ven bien (lo que implica que hay que tener cuidado con el formato de caractéres disponibles a elegir). Tambien existen juegos en lenguajes con otros alfabetos, a primera vista se encuentran ejemplos como chino y japones.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edate_release\u003c/strong\u003e: Fecha de salida del juego. En excel se pueden ver algunos campos marcados con ######, pero abiertos con un editor de texto se pueden ver las fechas sin problema (el formato es año-mes-dia)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ewin\u003c/strong\u003e: Indica si el juego es soportado por el sistema operativo Windows (campo booleano)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003emac\u003c/strong\u003e: Indica si el juego es soportado por el sistema operativo Mac (campo booleano)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003elinux\u003c/strong\u003e: Indica si el juego es soportado por el sistema operativo Linux (campo booleano)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003erating\u003c/strong\u003e: Que tanto recomienda la gente un juego (campo categórico polinomial, con categorías como: Positive, Very Positive, Mixed, Mostly Positive, Mostly Negative)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epositive_ratio\u003c/strong\u003e: Ratio de feedback positivo (campo integer)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003euser_reviews\u003c/strong\u003e: Cantidad de reviews de usuarios (campo integer)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eprice_final\u003c/strong\u003e: Precio en dolares (campo real)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eprice_original\u003c/strong\u003e: Precio original del juego en dolares (previo al descuento), suele ser igual al price_final (campo real)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ediscount\u003c/strong\u003e: Descuento que se le hace al juego. Si el juego esta descontado, disminuye el price_final, lo que hace que sea distinto a price_original (campo real)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003esteam_deck\u003c/strong\u003e: Si el juego esta disponible o no para la Steam Deck (campo booleano)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"csv-de-usuarios\"\u003eCSV de usuarios:\u003c/h5\u003e\n\u003cp\u003eEste CSV contiene información (anonimizada) acerca de usuarios registrados en Steam:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003euser_id\u003c/strong\u003e: ID de usuario autogenerada (campo integer)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eproducts\u003c/strong\u003e: Cantidad de juegos comprados por el usuario (campo integer)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ereviews\u003c/strong\u003e: Cantidad de reviews publicadas (campo integer)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"csv-de-recomendaciones\"\u003eCSV de recomendaciones:\u003c/h5\u003e\n\u003cp\u003eEste CSV contiene información acerca de las recomendaciones de los usuarios sobre un juego en particular:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eapp_id\u003c/strong\u003e: ID del juego en Steam (campo integer)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ehelpful\u003c/strong\u003e: Cantidad de usuarios que encontrar la recomendación útil (campo integer)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003efunny\u003c/strong\u003e: Cantidad de usuarios que encontrar la recomendación graciosa (campo integer)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edate\u003c/strong\u003e: Fecha de publicación (formato año-mes-día)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eis_recommended\u003c/strong\u003e: Si el usuario recomienda o no el juego (campo booleano)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ehours\u003c/strong\u003e: Cuantas horas jugó el usuario al juego (campo real)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003euser_id\u003c/strong\u003e: ID de usuario en Steam (campo integer)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ereview_id\u003c/strong\u003e: ID autogenerado de las reviews (campo integer)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5 id=\"json-de-metadata\"\u003eJSON de metadata:\u003c/h5\u003e\n\u003cp\u003eEste JSON profundiza y agrega información acerca de algunos de los juegos del CSV de juegos, con los siguientes datos:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eapp_id\u003c/strong\u003e: ID del juego en Steam (campo integer)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003edescription\u003c/strong\u003e: Descripción del juego (campo string)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003etags\u003c/strong\u003e: Lista de géneros del juego (campo categórico, con algunos ejemplos como: Action, Singleplayer, Hack and Slash, Controller, entre otros)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUna vez analizados y entendidos todos los datos, se puede evaluar que campos son los que nos interesan predecir. El caso más interesante sería el de ser capaz de predecir que juego le puede llegar a gustar a una persona (recomendacion de juegos).\nDado que la cantidad de datos en este dataset es tan grande, es de interés saber si podemos eliminar algun predictor que sepamos que no va a ser de utilidad. De esta forma podemos alivianar la carga sobre el modelo, ahorrando tiempo y costos de procesamiento. Para saber que predictores serán útiles para la tarea, se debe encontrar una forma de saber si a un usuario le podría gustar un juego o no. A lo largo de este proyecto se consideraron dos formas para recomendar juegos:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSaber que juegos suelen jugar otros usuarios similares (por ejemplo los juegos que tienen o recomiendan sus amigos, otros usuarios de su mismo país, etc.)\u003c/li\u003e\n\u003cli\u003eRecomendar juegos que tengan metadata similar a los que el usuario ya ha jugado y recomendado previamente\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"primer-approach\"\u003ePrimer approach\u003c/h3\u003e\n\u003cp\u003eLo primero que se intentó fue mergear los tres CSVs y el JSON utilizando pandas, con el objetivo de poder ver de forma unificada la información, y para poder envíarsela a RapidMiner o a un modelo en Python de forma sencilla y poder trabajar sobre el mismo conjunto de datos.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e json\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# leo los tres CSVs\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egames \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pd\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eread_csv(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;games.csv\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erecommendations \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pd\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eread_csv(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;recommendations.csv\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eusers \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pd\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eread_csv(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;users.csv\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# leo el JSON y lo convierto en un dataframe (tambien se puede usar pd.read_json())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejson_file_path \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;games_metadata.json\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ewith\u003c/span\u003e open(json_file_path, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;r\u0026#39;\u003c/span\u003e, encoding\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;utf-8\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e f:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    json_data \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [json\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eloads(line) \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e line \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e f]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf_metadata \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pd\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eDataFrame(json_data)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# ahora que está todo en el mismo formato, puedo mergear los dataframes usando app_id y user_id\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egames_recommendations \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pd\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003emerge(recommendations, games, on\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;app_id\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efull_data \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pd\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003emerge(games_recommendations, users, on\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;user_id\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efull_data_metadata \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e pd\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003emerge(full_data, df_metadata, on\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;app_id\u0026#39;\u003c/span\u003e, how\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;left\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efull_data_metadata\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eto_csv(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;steam_data.csv\u0026#39;\u003c/span\u003e, index\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eFalse\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(full_data_metadata\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ehead())\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e(tambien es posible mergear los CSVs desde RapidMiner, pero consume una enorme cantidad de recursos, y de faltar no permite continuar con la ejecución del bloque)\u003c/p\u003e\n\u003cp\u003eEl problema de este approach es que se genera un CSV con una cantidad de datos tan grande que RapidMiner, Excel, e incluso a editores de texto les cuesta incluso leerlo. Por lo tanto, se debe encontrar una forma de achicar los CSVs previo al mergeo.\u003c/p\u003e\n\u003ch3 id=\"segundo-approach\"\u003eSegundo approach\u003c/h3\u003e\n\u003cp\u003eDado que simplemente mergear todos los datos resultó inviable, el siguiente paso fue buscar si habían filas que no se podrían enviar al modelo. Por ejemplo, los tags son absolutamente necesarios para poder realizar recomendaciones en base al género de un juego, por lo que si un juego no tiene tags, entonces se puede descartar el juego, dado que falta información suficiente como para recomendarlo (se pueden utilizar otros campos, pero la recomendación no será tan acertada). Por lo tanto, se puede reducir la cantidad de datos en gran medida removiendo las filas que no poseen tags. Tambien es posible aprovechar y remover las filas que tienen descripción vacía, para intentar reducir la cantidad de datos.\nEl problema que tiene esto es que aún así la cantidad de datos sigue siendo muy grande. Por esta razón, se creó un script que aparte de remover las filas con una descripción y una lista de tags vacía, segmenta el CSV resultante en distintos CSVs, dando como resultado unos aproximadamente 400 CSVs, cada uno con una porción del CSV original.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-Python\" data-lang=\"Python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e dask.dataframe \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e dd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e numpy \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e np\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edtype \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;description\u0026#39;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;object\u0026#39;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;tags\u0026#39;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;object\u0026#39;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dd\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eread_csv(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;steam_data.csv\u0026#39;\u003c/span\u003e, dtype\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003edtype)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# cambio las descripiones vacías por NaN\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf[\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;description\u0026#39;\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e df[\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;description\u0026#39;\u003c/span\u003e]\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ereplace(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e, np\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003enan)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# borro las filas donde los tags sean \u0026#39;[]\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e df[df[\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;tags\u0026#39;\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;[]\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# borro las filas que tengan NaN en la descripción\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e df\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003edropna(subset\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e[\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;description\u0026#39;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Esta línea aparte de guardar el CSV lo divide en múltiples archivos (cleaned_dataset_1.csv, cleaned_dataset_2.csv, etc.)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eto_csv(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;cleaned_dataset_*.csv\u0026#39;\u003c/span\u003e, index\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eFalse\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"siguiendo-con-el-análisis\"\u003eSiguiendo con el análisis\u0026hellip;\u003c/h3\u003e\n\u003cp\u003eCon este último paso ya se comienza a poseer una cantidad de datos manejable, que se puede introducir en RapidMiner para comenzar con el desarrollo del proceso. Pero esto si solo se considera el tamaño del dataset.\nOtro problema que surge es que aun así RapidMiner no lo puede procesar, porque los géneros no dejan de ser una lista de tags separados por coma, lo que al momento de mergear con los CSVs genera un archivo que, al ingresar al RapidMiner, no sabe hasta donde llega cada columna, y por lo tanto genera errores.\nPara solucionar esto hay varios caminos. El primero sería sustituir las comas por otro símbolo en la lista de tags. Esto soluciona el problema del parseo, pero queda pendiente el ver como se puede formatear el dato para que un modelo de machine learning lo pueda procesar.\nPor otro lado, el segundo camino sería llevar cada uno de los tags a una columna binaria. Este segundo approach permite que la información se guarde de forma mas estructurada, y en forma de números binarios, que dependiendo del algoritmo de ML que se utilice, esto podría ser una ventaja (se pueden utilizar números o booleanos, y no representan un orden en particular, lo que sirve para este caso)\u003c/p\u003e\n\u003ch4 id=\"bibliografía\"\u003eBibliografía\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.kaggle.com/datasets/antonkozyriev/game-recommendations-on-steam\"\u003eDataset\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://pandas.pydata.org/pandas-docs/version/1.5/reference/api/pandas.DataFrame.dropna.html\"\u003ePandas docs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/29314033/drop-rows-containing-empty-cells-from-a-pandas-dataframe\"\u003eRemover celdas vacías\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.kaggle.com/code/felipereisdesouza/recommended-game-genres\"\u003eOtros estudios del dataset\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.kaggle.com/code/thakursankalp/steam-game-recommendation-engine\"\u003eOtros estudios del dataset\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n","description":null,"image":null,"permalink":"https://seba-quintana.github.io/ML-Portfolio/blogs/steam/","title":"Recomendaciones de juegos"},{"content":"","description":null,"image":null,"permalink":"https://seba-quintana.github.io/ML-Portfolio/blogs/laptops/","title":"Precios de laptops"}]